Notes for the MPFR developers and CVS users
===========================================

To compile source code obtained from CVS, you need some GNU development
utilities: aclocal, autoheader, automake, autoconf 2.50 (at least). As
some files like "configure" are not part of the CVS repository, you
first need to run "autoreconf"; if you have both autoconf 2.13 and 2.50
installed and use a wrapper, you may need to run "autoreconf" a second
time (as with old Debian packages, due to a bug in the wrapper). Then
you can run "configure" in the usual way (see the INSTALL file).

If for some reason, this doesn't work, there's still the old way: run
the "prepare" script to generate these files; as the "prepare" script
also runs "configure", you must give the options that will be passed
to "configure", for instance: ./prepare --with-gmp=/path/to/gmp
Give "--help" if you don't know (./prepare --help). Then, you can
use the configure script as usual. Read the INSTALL file for more
information. If you use GNU tools, you can give "-dev" as the first
option to the "prepare" script to get better dependency tracking.

To generate mpfr.info, you need texinfo version 4.2 (or higher).

===========================================================================

The VERSION file contains the number of the next release version, i.e.
the version currently developed. If nightly snapshots are built, the
date in the yyyymmdd format must be added to the version number, for
instance: "2.0.1-20020319".

===========================================================================

When submitting patches, unified diffs (option -u) are recommended,
as they are more readable. You can also use the option -d to generate
a smaller set of changes. See diff(1) for more information.

===========================================================================

To make a release (for the MPFR team):

  1) Check the version and update the date in mpfr.texi.
  2) Update the NEWS file.
  3) Update the ChangeLog file (using a recent version of rcs2log,
     directly or with emacs), e.g. rcs2log > ChangeLog.2 and edit
     ChangeLog to insert ChangeLog.2 at the beginning and remove
     the duplicated lines.
  4) Fix the file permissions that have been broken by CVS.
  5) Generate the release version with "make dist".
  6) Test the release version on different machines, with and without
     the --disable-alloca configure option (or compile gmp with
     --enable-alloca=debug), with and without -DXDEBUG in $CFLAGS,
     with and without gmp internal files, with and without gmp built
     as a shared library, with and without srcdir equals to objdir
     (../mpfr/configure --srcdir=/users/spaces/pelissip/mpfr/).
  7) If there is no problem, add a tag to the CVS corresponding to the
     release, e.g. mpfr-2-0-1-rel for mpfr 2.0.1 (note that the periods
     are replaced by dashes): cvs tag mpfr-2-0-1-rel
  8) Update the version with the update-version script to indicate the
     next version.

A branch may be created first (e.g. with "cvs tag -b mpfr-2-0-2-branch")
to allow new features to be committed to the trunk.

===========================================================================

To check the coverage of the Test Suite, you can use GCOV.
   ./configure CFLAGS="-fprofile-arcs -ftest-coverage"
   make clean
   make check
   find . -name '*.c' -exec gcov '{}' ';' | grep "lines executed" | sort

For each source file, there is a .c.gcov file which contains much more
information. Building this version in a different directory is usually
a good idea:
   mkdir cov
   cd cov
   ../configure CFLAGS="-fprofile-arcs -ftest-coverage" --srcdir=..
   make check
   find .. -name '*.c' -exec gcov '{}' ';' | grep "lines executed" | sort

===========================================================================

List of the used macros for building MPFR:

+ HAVE_STRCASECMP: 	Define if the system supports 'strcasecmp' function.
+ HAVE_STRNCASECMP:	Define if the system supports 'strncasecmp' function.

+ HAVE_CONFIG_H:        Define if we have to include 'config.h' first.
+ MPFR_HAVE_GMP_IMPL:	Define if we have the gmp internal files.
			 ('gmp-impl.h', 'gmp-maparam.h', ...).

+ HAVE_ALLOCA_H:	Define if the function 'alloca' is in alloca.h.
+ HAVE_LONG_LONG:	Define if the system supports 'long long'

+ HAVE_STDARG:		Define if the system supports 'stdarg.h'.
			 Otherwise it is assumed it is 'vararg.h'.
+ HAVE_STDINT_H:	Define if 'intmax_t' is supported (ISO C99).

 Define format of long double.
+ HAVE_LDOUBLE_IEEE_EXT_LITTLE:         IEEE extended, little endian.
+ HAVE_LDOUBLE_IEEE_QUAD_BIG:           IEEE quad, big endian.

+ XDEBUG:		Use generic 'double' code instead of IEEE specific one.
			The IEEE code for double needs GMP internal files.
+ WANT_ASSERT:		Define if we want to turn on the assertions.
+ MPFR_EXP_CHECK:	Define if we want to check the exp field.

+ MPFR_PREC_FORMAT:	Define the internal format of prec field
			 (For experimented users).

+ IEEE_DBL_MANT_DIG:	Number of bits in the mantissa of a double.
			(Default: 53).
+ LDBL_MANT_DIG:	Number of bits in the mantissa of a long double

List of the used macros for checking MPFR:

+ MPFR_HAVE_FESETROUND:	Define if the fesetround function is defined
			 (and in header fenv.h).
+ HAVE_DENORMS:		Define if denormalized floats work.
+ HAVE_SYS_TIME_H:	Define if the header sys/time.h is usuable.
+ HAVE_GETTIMEOFDAY:	Define if the function gettimeofday is present.
+ MPFR_HAVE_TESTS_x86:	Define if we are on x86.

===========================================================================

The GNU Coding standards can be read at:
  http://www.gnu.org/prep/standards_toc.html
ISO C Names and corresponding headers:
  http://www.schweikhardt.net/identifiers.html
Language C:
  http://www.vmunix.com/~gabor/c/draft.html

To allow MPFR to be built on some buggy compiler, try to follow
theses rules:

   =====================================================================

Don't write:
  mp_limb_t l;
  [...]
  if (l) do_action ();
But:
  mp_limb_t l;
  [...]
  if (l != 0) do_action ();

 since mp_limb_t may be "unsigned long long", and some buggy compiler
produce illegal codes with the first form.

   =====================================================================

Don't use "near" and "far" as variable names since they are "Keywords"
for some C compiler (Old DOS compiler).

   =====================================================================

Try to avoid "LONG_MIN/1" since it produces a SIGNAL on (old) FreeBsd.

   =====================================================================

Though the ISO C standard requires that <stdlib.h> defines NULL,
do not use NULL with #include <stdlib.h> only, because this will
not work with the native SunOS 4 C compiler, whose headers are
not conform to the standard (even with C90); other problems may
occur on this architecture. You can either include <stdio.h> or
use 0 (possibly casted to the target pointer type).

   ====================================================================

In the tests, do not use `mpfr_set_d` (except when testing it), as the
result will depend on the floating-point arithmetic of the system;
this has shown many problems in the past and problems may still occur
with new systems. Use `mpfr_set_si` or `mpfr_set_str` instead.

   ====================================================================

If you have to mix TMP_DECL and MPFR_SAVE_EXPO_DECL in the declaring
section of your function, please declare MPFR_SAVE_EXPO_DECL before
TMP_DECL, since TMP_DECL may be replace by nothing:

Instead of:                                 Usually preprocessed as:
  unsigned long t                             unsigned long t; 
  TMP_DECL (maker);                           ;
  MPFR_SAVE_EXPO_DECL (expo);                 mpfr_save_expo_t expo;
use:
  unsigned long t                             unsigned long t;
  MPFR_SAVE_EXPO_DECL (expo);                 mpfr_save_expo_t expo;
  TMP_DECL (maker);                           ;

===========================================================================

If you plan to add a new function, you could follow this schema:

int
mpfr_toto (mpfr_ptr rop, mpfr_srcptr op, mp_rnd_t rnd)
{
  [Declarate all used variables]
  int inexact;
  mp_prec_t prec;
  MPFR_SAVE_EXPO_DECL (expo);

  /* First deal with particular cases */
  if (MPFR_UNLIKELY (MPFR_IS_SINGULAR (op)))
    {
      if (MPFR_IS_NAN (op))
        {
         MPFR_SET_NAN (rop);
         MPFR_RET_NAN;
        }
      else if (MPFR_IS_INF (op))
        { 
         [Code to deal with Infinity]
        }
      else
        {
          MPFR_ASSERTD (MPFR_IS_ZERO (op));
          [Code to deal with Zero]
        }
    }
  [Other particular case: For example, op<0 or op == 1]

  [Compute the first estimation of the used precision `prec`]
  [Initalize the intermediate variables using mpfr_init2]
  MPFR_SAVE_EXPO_MARK (expo);            /* Maximal range for exponent */

  for (;;)                               /* Infinite loop */
    {
      [Compute an estimation of the function and]
      [ an estimation of the error].
      if (mpfr_can_round (...))          /* If we can round, quit the loop */
        break;
      prec += BITS_PER_MP_LIMB;          /* Increase used precision */
      [Using `mpfr_set_prec`, resize all needed intermediate variables]
    }
  
  inexact = mpfr_set (rop, temp, rnd);   /* Set rop to the computed value */
  [Clear all intermediate variables]

  MPFR_SAVE_EXPO_FREE (expo);            /* Restore exponent range */
  return mpfr_check_range (rop, inexact, rnd); /* Quit and check range */
}
