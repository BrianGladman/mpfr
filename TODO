Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005 Free Software Foundation.
Contributed by the Spaces project, INRIA Lorraine.

This file is part of the MPFR Library.

The MPFR Library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License (either version 2.1
of the License, or, at your option, any later version) and the GNU General
Public License as published by the Free Software Foundation (most of MPFR is
under the former, some under the latter).

The MPFR Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the MPFR Library; see the file COPYING.LIB.  If not, write to
the Free Software Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.

##############################################################################

Documentation:

- add a description of the algorithms used + proof of correctness

- mpfr_set_prec: add an explanation of how to speed up calculations
  which increase their precision at each step.



Installation:

- from Kevin Ryde <user42@zip.com.au>:
  Determine the exp2/exp3 thresholds using tune/tuneup.c.
  A start has been made on this, but there's a noticable step-effect
  in the times making them cross back and forward between which is
  faster.  Hopefully this will go away with improvements to the exp
  code.



Changes in existing functions:

- mpfr_get_str should support base up to 62 too.

- mpfr_can_round:
   change the meaning of the 2nd argument (err). Currently the error is
   at most 2^(MPFR_EXP(b)-err), i.e. err is the relative shift wrt the
   most significant bit of the approximation. I propose that the error
   is now at most 2^err ulps of the approximation, i.e.
   2^(MPFR_EXP(b)-MPFR_PREC(b)+err).

- mpfr_set_q first tries to convert the numerator and the denominator
  to mpfr_t. But this convertion may fail even if the correctly rounded
  result is representable. New way to implement:
  Function q = a/b.  nq = PREC(q) na = PREC(a) nb = PREC(b)
    If na < nb
       a <- a*2^(nb-na)
    n <- na-nb+ (HIGH(a,nb) >= b)
    if (n >= nq)
       bb <- b*2^(n-nq)
       a  = q*bb+r     --> q has exactly n bits.
    else
       aa <- a*2^(nq-n)
       aa = q*b+r      --> q has exaclty n bits.
  If RNDN, takes nq+1 bits. (See also the new division function).

New functions to implement:

- modf (to extract integer and fractional parts), suggested by
	Dmitry Antipov <dmitry.antipov@mail.ru> Thu, 13 Jun 2002
- those from LIA: missing secant, cosecant, cotangent (trigo/hyperbolic)
- mpfr_root to compute x^(1/n) for n integer, similar to mpz_root
	[suggested by Damien Fisher, damien@maths.usyd.edu.au, 20 Jul 2003,
	and Mark Watkins <watkins@maths.usyd.edu.au>, 23 Jul 2003]
- mpfr_fmod (mpfr_t, mpfr_srcptr, mpfr_srcptr, mp_rnd_t)
  [suggested by Tomas Zahradnicky <tomas@24uSoftware.com>, 29 Nov 2003]
  Kevin: Might want to be called mpfr_mod, to match mpz_mod.
  -> we probably want to allow both mpfr_fmod and mpfr_mod.
- mpfr_fms for a-b*c
  [suggested by Tomas Zahradnicky <tomas@24uSoftware.com>, 29 Nov 2003]
- 1/sqrt(x) [Regis Dupont <dupont@lix.polytechnique.fr>, 15 Sep 2004]
- dilog() [the dilogarithm: dilog(x) =  int(ln(t)/(1-t), t=1..x)]
- mpfr_printf [Sisyphus <kalinabears@iinet.net.au> Tue, 04 Jan 2005]
  for example mpfr_printf ("%.2Ff\n", x)



Efficiency:

- speed up mpfr_atan for large arguments (to speed up mpc_log)
	[from Mark Watkins on Fri, 18 Mar 2005]
- implement range reduction in sin/cos/tan for large arguments
	(currently too slow for 2^1024), and/or implement Mark Watkins's
	algorithm:
  My suggestion for a long-term fix to these sin/cos problems when one
  of them is close to zero is the following:
  Give input inp:
  1) Reduce inp to the interval 0 to Pi/2
  2) If inp is less than Pi/4, compute sin(inp) via a power series around 0.
  3) If inp is more than Pi/4, compute s=Pi/2-inp to the working precision
     (most of the possible cancellation will occur here --- or in step 1)
     and calculate cos(inp) as a power series (in s) around Pi/2 --- thus
     the output is near zero precisely when the s-input is near zero,
     avoiding most cancellation problems.
  4) Having sin or cos, compute the other via the sqrt. This will not cause
     cancellation problems because the computed sin or cos is not near 1.
- mpfr_asin/acos are too slow for small values (2^(-1021) for example)
- idem for mpfr_atanh (2^(-1021) for example)
- improve generic.c to work for number of terms <> 2^k
- rewrite mpfr_greater_p... as native code.

- mpf_t uses a scheme where the number of limbs actually present can
  be less than the selected precision, thereby allowing low precision
  values (for instance small integers) to be stored and manipulated in
  an mpf_t efficiently.

  Perhaps mpfr should get something similar, especially if looking to
  replace mpf with mpfr, though it'd be a major change.  Alternately
  perhaps those mpfr routines like mpfr_mul where optimizations are
  possible through stripping low zero bits or limbs could check for
  that (this would be less efficient but easier).

Miscellaneous:

- rename mpf2mpfr.h to gmp-mpf2mpfr.h?
  (will wait until mpfr is fully integrated into gmp :-)

- from Kevin Ryde <user42@zip.com.au>:
   Also for pi.c, a pre-calculated compiled-in pi to a few thousand
   digits would be good value I think.  After all, say 10000 bits using
   1250 bytes would still be small compared to the code size!
   Store pi in round to zero mode (to recover other modes).

- add a new rounding mode: rounding away from 0. This can be easily
  implemented as follows: round to zero, and if the result is inexact,
	add one ulp to the mantissa.
- add a new rounding mode: round to nearest, with ties away from zero
  (will be in 754r, could be used by mpfr_round)
- add a new roundind mode: round to odd. If the result is not exactly
	representable, then round to the odd mantissa. This rounding
	has the nice property that for k > 1, if:
	y = round(x, p+k, TO_ODD)
        z = round(y, p, TO_NEAREST_EVEN), then
        z = round(x, p, TO_NEAREST_EVEN)
  so it avoids the double-rounding problem.

- check/define the sign of infinity for gamma(-integer)

- add tests of the ternary value for constants

- When doing Extensive Check (--enable-assert=full), since all the
  functions use a similar use of MACROS (ZivLoop, ROUND_P), it should 
  be possible to do such a scheme:
    For the first call to ROUND_P when we can round.
    Mark it as such and save the approximated rounding value in 
    a temporary variable.
    Then after, if the mark is set, check if:
      - we still can round.
      - The rounded value is the same.
  It should be a complement to tgeneric tests.

Portability:

- [Kevin about texp.c long strings]
  For strings longer than c99 guarantees, it might be cleaner to
  introduce a "tests_strdupcat" or something to concatenate literal
  strings into newly allocated memory.  I thought I'd done that in a
  couple of places already.  Arrays of chars are not much fun.



Possible future MPF / MPFR integration:

- mpf routines can become "extern inline"s calling mpfr equivalents,
  probably just with GMP_RNDZ hard coded, since that's what mpf has
  always done.

- Want to preserve the mpf_t structure size, for binary compatibility.
  Breaking compatibility would cause lots of pain and potential subtle
  breakage for users.  If the fields in mpf_t are not enough then
  extra space under _mp_d can be used.

- mpf_sgn has been a macro directly accessing the _mp_size field, so a
  compatible representation would be required.  At worst that field
  could be maintained for mpf_sgn, but not otherwise used internally.

  mpf_sgn should probably throw an exception if called with NaN, since
  there's no useful value it can return, so it might want to become a
  function.  Inlined copies in existing binaries would hopefully never
  see a NaN, if they only do old-style mpf things.

- mpfr routines replacing mpf routines must be reentrant and thread
  safe, since of course that's what has been documented for mpf.

- mpfr_random will not be wanted since there's no corresponding
  mpf_random and new routines should not use the old style global
  random state.
