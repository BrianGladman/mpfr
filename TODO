Documentation:

- add a description of the algorithms used + proof of correctness

Installation:

- from Kevin Ryde <user42@zip.com.au>:
   Determine the exp2/exp3 thresholds using tune/tuneup.c.

Changes in existing functions:

- invert 2nd and 3rd arguments of mpfr_round_prec (to be coherent with
	mpfr_set_prec)
- merge mpfr_inp_str and mpfr_set_str (cf glibc sscanf/fscanf)
- remove mpfr_set_machine_rnd_mode from the documentation,
	and move it to the test directory
- in mpfr_set_str, make string comparisons case insensitive and use @Inf@
  and @NaN@ instead of the possibly ambiguous Inf and NaN in bases > 10.
  Modify the other functions to make them consistent with this choice.
  Possibly accept other strings, like those accepted by strtod.
- implement ternary flag for mpfr_agm: result is exact when u=v, or u=0,
  or v=0.
- use nextafter/nexttoward instead of add_one_ulp/sub_one_ulp in mpfr_exp
	(they differ for a power of 2)
- thread-safe version of mpfr_set_q wrt temporary changes in emin/emax?
	Suggested by Kevin.

New functions to implement:

- modf (to extract integer and fractional parts), suggested by
	Dmitry Antipov <dmitry.antipov@mail.ru> Thu, 13 Jun 2002
- mpz_set_fr (to set a mpz from a mpfr, with a rounding mode)
- those from LIA: missing secant, cosecant, cotangent (trigo/hyperbolic)
- nextafter/nextforward : X + epsilon if X < Y, X - epsilon if X > Y
- nextabove/nextbelow ?
- mpfr_get_exp / mpfr_set_exp
- mpfr_greater_p (Kevin, Vincent ok)
                         =     <     >     unordered
mpfr_greater_p           0     0     1     0
mpfr_greaterequal_p      1     0     1     0
mpfr_less_p              0     1     0     0
mpfr_lessequal_p         1     1     0     0
mpfr_lessgreater_p       0     1     1     0
mpfr_equal_p             1     0     0     0
mpfr_unordered_p         0     0     0     1

- mpfr_set_f (MPF -> float) or mpfr_strtof, mpfr_set_ld or mpfr_strtold
	(idem for mpfr_get_*)
- implement accurate summation algorithms from Demmel
	(http://www.cs.berkeley.edu/~demmel/AccurateSummation.ps)

Rounding:

- mpfr_pow -> loops when exact (for example 4^(1/2)).
- mpfr_pow isn't completely specified (concerning signed zeros).

Efficiency:

- implement range reduction in sin/cos/tan for large arguments
	(currently too slow for 2^1024)
- mpfr_asin/acos are too slow for small values (2^(-1021) for example)
- idem for mpfr_atanh (2^(-1021) for example)

Miscellaneous:

- rename mpf2mpfr.h to gmp-mpf2mpfr.h?

- add mpfr_get_ld for 'long double' [asked by J-C Fauge`re] ?
  (exists since K&R, but has not necessarily a greater precision than double)
  cf http://anubis.dkuug.dk/jtc1/sc22/wg14/www/docs/n869/
	[cf above]

- from Kevin Ryde <user42@zip.com.au>:
   Also for pi.c, a pre-calculated compiled-in pi to a few thousand
   digits would be good value I think.  After all, say 10000 bits using
   1250 bytes would still be small compared to the code size!
   Store pi in round to zero mode (to recover other modes).

- problem when reading a float followed by a character, for example 1.5*x
	[from Fabrice.Rouillier@loria.fr, Mon, 04 Dec 2000]

- rewrite mpfr_get_str and mpfr_set_str to use mpn_get_str and mpn_set_str.
	(Torbjorn Granlund <tege@swox.com>, 30 Jan 2002)

- rename (and rewrite) mpfr_isinteger to mpfr_integer_p.
	(Kevin Ryde, 05 Mar 2002)

- use GMP rand/srand functions instead for SEED_RAND (time(NULL)). Kevin:
  GMP tests/misc.c has a scheme to print the seed chosen and allow for a
  re-run with a given seed.  If you moved towards _gmp_rand and friends
  at some stage you could probably use that scheme almost unchanged.
  An advantage of _gmp_rand of course is that it's the same on all
  systems, apart from limb size, so you're not at the mercy of random or
  lrand48, etc.

- make MPFR thread-safe.
