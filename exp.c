/* mpfr_exp -- exponential of a floating-point number

Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
Contributed by the Arenaire and Cacao projects, INRIA.

This file is part of the MPFR Library.

The MPFR Library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or (at your
option) any later version.

The MPFR Library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
License for more details.

You should have received a copy of the GNU Lesser General Public License
along with the MPFR Library; see the file COPYING.LIB.  If not, write to
the Free Software Foundation, Inc., 51 Franklin St, Fifth Floor, Boston,
MA 02110-1301, USA. */

#include "mpfr-impl.h"

/* #define DEBUG */

int
mpfr_exp (mpfr_ptr y, mpfr_srcptr x, mp_rnd_t rnd_mode)
{
  mp_exp_t expx;
  mp_prec_t precy;
  int inexact;
  MPFR_SAVE_EXPO_DECL (expo);

  MPFR_LOG_FUNC (("x[%#R]=%R rnd=%d", x, x, rnd_mode),
                 ("y[%#R]=%R inexact=%d", y, y, inexact));

  if (MPFR_UNLIKELY( MPFR_IS_SINGULAR(x) ))
    {
      if (MPFR_IS_NAN(x))
        {
          MPFR_SET_NAN(y);
          MPFR_RET_NAN;
        }
      else if (MPFR_IS_INF(x))
        {
          if (MPFR_IS_POS(x))
            MPFR_SET_INF(y);
          else
            MPFR_SET_ZERO(y);
          MPFR_SET_POS(y);
          MPFR_RET(0);
        }
      else
        {
          MPFR_ASSERTD(MPFR_IS_ZERO(x));
          return mpfr_set_ui (y, 1, rnd_mode);
        }
    }

  /* First, let's detect the underflow and overflow. */
  /* FIXME: This is still incorrect for the underflow since MPFR chose
     underflow after rounding (the result is correct, though, only the
     underflow flag may not). Some overflow cases may not be detected
     (it would probably too difficult to detect them here), but is this
     sufficient for the generic algorithms?
     - After a simple modification to do like in the generic case of
       mpfr_pow, exp_2.c can really detect exceptions rigorously: the
       final mpfr_mul_2si must be done after MPFR_CAN_ROUND and the
       rounding.
     - The exp3.c routine computes a lower bound on the result, thus
       detects overflows rigorously. Concerning the underflow, this
       can be detected by a scaling. As the last operation is a square
       (z^2), the scaling is needed (and very easy to do) only if an
       underflow is generated by this operation. [Fixed in r5469]
     As a consequence, we won't need a rigorous underflow/overflow
     detection test here in exp.c (only the main cases of underflow
     and overflow). */
  {
    mpfr_t elo, ehi, bound;
    int slo, shi;
    mp_prec_t prec = 32;

    /* We must extended the exponent range and save the flags now. */
    MPFR_SAVE_EXPO_MARK (expo);

    mpfr_inits2 (sizeof (mp_exp_t) * CHAR_BIT, elo, ehi, (mpfr_ptr) 0);
    inexact = mpfr_set_exp_t (elo, expo.saved_emin, GMP_RNDN);
    MPFR_ASSERTD (inexact == 0);
    inexact = mpfr_sub_ui (elo, elo, 1, GMP_RNDN);
    MPFR_ASSERTD (inexact == 0);
    /* If elo > 0 and elo - 1 > 0, then slo = 0.
     * If elo < 0 and elo - 1 < 0, then slo = 1.
     * So, slo = 1 iff elo <= 0 iff expo.saved_emin <= 1.
     */
    slo = expo.saved_emin <= 1;
    inexact = mpfr_set_exp_t (ehi, expo.saved_emax, GMP_RNDN);
    MPFR_ASSERTD (inexact == 0);
    shi = expo.saved_emax < 0;
    mpfr_init2 (bound, prec);

    while (1)
      {
        mpfr_const_log2 (bound, shi ? GMP_RNDU : GMP_RNDD);
        mpfr_mul (bound, bound, ehi, GMP_RNDD);
        if (MPFR_LIKELY (mpfr_cmp (x, bound) <= 0))
          {
            mpfr_const_log2 (bound, slo ? GMP_RNDD : GMP_RNDU);
            mpfr_mul (bound, bound, elo, GMP_RNDU);
            if (MPFR_LIKELY (mpfr_cmp (x, bound) >= 0))
              break;  /* Neither underflow, nor overflow */
            /* Probable underflow */
            mpfr_const_log2 (bound, slo ? GMP_RNDU : GMP_RNDD);
            mpfr_mul (bound, bound, elo, GMP_RNDD);
            if (MPFR_LIKELY (mpfr_cmp (x, bound) <= 0))
              {
                /* Underflow */
                if (rnd_mode != GMP_RNDN)
                  {
                    mpfr_clears (elo, ehi, bound, (mpfr_ptr) 0);
                    MPFR_SAVE_EXPO_FREE (expo);
                    return mpfr_underflow (y, rnd_mode, 1);
                  }
                /* Rounding-to nearest mode: we also need to decide
                   whether the result is 0 or nextabove(0). */
                inexact = mpfr_sub_ui (elo, elo, 1, GMP_RNDN);
                MPFR_ASSERTD (inexact == 0);
                while (1)
                  {
                    mpfr_const_log2 (bound, slo ? GMP_RNDU : GMP_RNDD);
                    mpfr_mul (bound, bound, elo, GMP_RNDD);
                    if (MPFR_LIKELY (mpfr_cmp (x, bound) <= 0))
                      {
                        /* Underflow with result = 0 */
                        mpfr_clears (elo, ehi, bound, (mpfr_ptr) 0);
                        MPFR_SAVE_EXPO_FREE (expo);
                        return mpfr_underflow (y, GMP_RNDZ, 1);
                      }
                    mpfr_const_log2 (bound, slo ? GMP_RNDD : GMP_RNDU);
                    mpfr_mul (bound, bound, elo, GMP_RNDU);
                    if (MPFR_LIKELY (mpfr_cmp (x, bound) >= 0))
                      {
                        /* Underflow with result = nextabove(0) */
                        mpfr_clears (elo, ehi, bound, (mpfr_ptr) 0);
                        MPFR_SAVE_EXPO_FREE (expo);
                        return mpfr_underflow (y, GMP_RNDN, 1);
                      }
                    /* We couldn't decide: more precision is needed. */
                    prec += prec < MPFR_PREC (x) ? MPFR_PREC (x) : prec / 2;
                    mpfr_set_prec (bound, prec);
                  }
                MPFR_RET_NEVER_GO_HERE ();
              }
            /* We couldn't decide: more precision is needed. */
          }
        else
          {
            /* Probable overflow */
            mpfr_const_log2 (bound, shi ? GMP_RNDD : GMP_RNDU);
            mpfr_mul (bound, bound, ehi, GMP_RNDU);
            if (MPFR_LIKELY (mpfr_cmp (x, bound) >= 0))
              {
                mpfr_clears (elo, ehi, bound, (mpfr_ptr) 0);
                MPFR_SAVE_EXPO_FREE (expo);
                return mpfr_overflow (y, rnd_mode, 1);
              }
            /* We couldn't decide: more precision is needed. */
          }
        prec += prec < MPFR_PREC (x) ? MPFR_PREC (x) : prec / 2;
        mpfr_set_prec (bound, prec);
      }

    mpfr_clears (elo, ehi, bound, (mpfr_ptr) 0);
    MPFR_SAVE_EXPO_FREE (expo);
  }

  MPFR_CLEAR_FLAGS (y);

  expx  = MPFR_GET_EXP (x);
  precy = MPFR_PREC (y);

  /* if x < 2^(-precy), then exp(x) i.e. gives 1 +/- 1 ulp(1) */
  if (MPFR_UNLIKELY (expx < 0 && (mpfr_uexp_t) (-expx) > precy))
    {
      mp_exp_t emin = __gmpfr_emin;
      mp_exp_t emax = __gmpfr_emax;
      int signx = MPFR_SIGN (x);

      MPFR_SET_POS (y);
      if (MPFR_IS_NEG_SIGN (signx) && (rnd_mode == GMP_RNDD ||
                                       rnd_mode == GMP_RNDZ))
        {
          __gmpfr_emin = 0;
          __gmpfr_emax = 0;
          mpfr_setmax (y, 0);  /* y = 1 - epsilon */
          inexact = -1;
        }
      else
        {
          __gmpfr_emin = 1;
          __gmpfr_emax = 1;
          mpfr_setmin (y, 1);  /* y = 1 */
          if (MPFR_IS_POS_SIGN (signx) && rnd_mode == GMP_RNDU)
            {
              mp_size_t yn;
              int sh;

              yn = 1 + (MPFR_PREC(y) - 1) / BITS_PER_MP_LIMB;
              sh = (mp_prec_t) yn * BITS_PER_MP_LIMB - MPFR_PREC(y);
              MPFR_MANT(y)[0] += MPFR_LIMB_ONE << sh;
              inexact = 1;
            }
          else
            inexact = -MPFR_FROM_SIGN_TO_INT(signx);
        }

      __gmpfr_emin = emin;
      __gmpfr_emax = emax;
    }
  else  /* General case */
    {
      if (MPFR_UNLIKELY (precy > MPFR_EXP_THRESHOLD))
        /* mpfr_exp_3 saves the exponent range and flags itself, otherwise
           the flag changes in mpfr_exp_3 are lost */
        inexact = mpfr_exp_3 (y, x, rnd_mode); /* O(M(n) log(n)^2) */
      else
        {
          MPFR_SAVE_EXPO_MARK (expo);
          inexact = mpfr_exp_2 (y, x, rnd_mode); /* O(n^(1/3) M(n)) */
          MPFR_SAVE_EXPO_FREE (expo);
        }
    }

  return mpfr_check_range (y, inexact, rnd_mode);
}
