Implementation of mpfr_sum: sum of n mpfr_t values
══════════════════════════════════════════════════

About the time/memory complexity: The original mpfr_sum algorithm was
inefficient on some inputs, and in some simple cases with inputs of
different orders of magnitude, it could be very slow and take all the
memory, making the whole program (and possibly other programs on the
system too, due to the lack of memory at some critical point) crash.
The time/memory complexity must no longer depend on the value of the
exponents of the inputs, i.e. their order of magnitude. Moreover, be
careful with the carry propagation.

Preliminary note: The previous mpfr_sum algorithm was a high-level one
and could take too much memory and too much time in cases with numbers
of different magnitudes and cancellation. Here we will use functions
from the mpn layer of GMP only (no mpfr_add), as the algorithm is based
on additions by blocks, involving virtual splitting of MPFR numbers.

Let sq be the output precision.

The general ideas of the algorithm:

0. Handle the case n <= 1 separately (+0 for n = 0, mpfr_set for n = 1).
   Now assume that n >= 2.

1. Look at the exponent field of each mpfr_t input (this is fast); also
   track the signs of Inf's and zeros. This step allows one to:
   * detect the singular cases, i.e. when there is either at least a NaN
     or an Inf in the inputs (in case of a NaN or two Inf's of different
     signs, we can immediately return NaN), or all inputs are zeros;
   * determine the maximum exponent maxexp of the regular inputs and
     the number n' of regular inputs.

2. A truncated sum will be computed in two's complement, stored in a
   fixed memory area, called "accumulator", whose characteristics are
   determined here.

   Only a fixed part of the inputs will be taken into account for the
   truncated sum: the bits whose exponent is in some window (interval)
   denoted [minexp,maxexp[.

   We choose not to include maxexp in the interval in order to match the
   floating-point representation chosen in MPFR, where the significand
   is in [1/2,1[; this also means that the current minexp will be maxexp
   at the next iteration, unless there is a "hole" between the inputs,
   as explained below.

   Let us define logn = ceil(log2(n')).

   Due to the accumulation of values and the choice of two's complement
   (a way to represent the sign), we will need some extra bits to avoid
   overflows. The absolute value of the sum is less than n' * 2^maxexp,
   taken up to logn extra bits, and one needs one more bit to be able
   to determine the sign, so that cq = logn + 1 extra bits will be
   considered.

   For the other side, we define minexp = maxexp - sq - dq, where dq
   will be chosen around logn to take into account the accumulation
   of errors, i.e. from everything less significant than minexp. The
   final choice for dq should be done after testing: in practice, one
   may need a little more precision to handle partial cancellation at
   this iteration, but important cancellation will always lead to other
   iterations. For instance, we will choose for dq the smallest value
   such that dq ≥ max(logn,3) (the bound 3 will be explained later),
   and the accumulator bitsize, which is maxexp + cq - minexp, i.e.
   cq + sq + dq, is a multiple of GMP_NUMB_BITS.

   Accumulator:  [--------]-----------------------------------]
                     cq   └─ maxexp      sq + dq      minexp ─┘

3. Compute the truncated sum in two's complement by taking into account
   the part of the inputs in the window [minexp,maxexp[.

   In the same loop over the inputs, determine the maximum exponent
   maxexp2 of the numbers formed starting with the most significant
   represented bit that has been ignored: one will get either minexp
   (if an input has been truncated at this iteration) or the maximum
   exponent of the numbers that have been completely ignored.

   The accumulator during this iteration:

                 [--------]-----------------------------------]
                     cq   └─ maxexp                   minexp ─┘

   If there is a additional iteration with maxexp2 = minexp - 4 and
   a shift of 26 bits, here's the accumulator after the shift:

                                     <------- 26 zeros ------->
                 [-------------------0000000000000000000000000]
   This iteration:          minexp ─┘   ├─ maxexp2            │
   Next iteration:                      └─ maxexp     minexp ─┘

4. Determine the number of cancelled bits, more precisely, define the
   variable cancel = number of identical bits on the most significant
   part of the accumulator.

5. If the truncated sum (i.e. the value of the accumulator) is 0, i.e.
   if all the words are 0, then reiterate at (3) with maxexp = maxexp2.

6. Let e = maxexp + cq - cancel, q = e - sq, and err = minexp + logn.
   Then the absolute value of the truncated sum is in [2^(e-1),2^e]
   (binade closed on both ends due to two's complement), q is the
   quantum exponent in the destination (except in the exact case -2^e),
   and the error is strictly less than 2^err. Here's a representation
   of the accumulator and the cancel bits, with the two cases depending
   on the sign of the truncated sum, where the x's correspond to the
   represented bits following the initial 1 (0 if negative), r is the
   rounding bit, and the f's are the following bits:

     ][------------------- accumulator -------------------]
     ][---- cancel ----]----------------------------------]
     ]0000000000000000001xxxxxxxxxxxxxxxxxxxxxrffffffffffff
     ]1111111111111111110xxxxxxxxxxxxxxxxxxxxxrffffffffffff
     └─ maxexp + cq    └─ e               q ─┘    minexp ─┘

   The exponent and related values may change due to the error, but
   this doesn't really matter here.

   If the cancellation is important, e.g. so that err > q - 3, then
   one reiterates at (3) after shifting the truncated sum to the
   left boundary (most significant part) of the accumulator, where:
   * the shift count is determined in such a way to avoid overflows
     at the next iteration, i.e. to be able to retrieve the sum with
     its sign;
   * the new value of cq is implied by this shift count and maxexp2
     (the value of maxexp at the next iteration).

   Concerning the choice of the shift count, letting only one identical
   bit in the most significant part may not be sufficient; for instance,
   if maxexp2 = minexp and the accumulator

        0000000011111111111111111111111111110101
   This iteration:                     minexp ─┘

   is shifted to

        0111111111111111111111111111101010000000
   Next iteration:                      └─ maxexp

   and there are at least 12 numbers to add at the next iteration, then
   one could end up with something like:

        1000000000000000000000000000000000010001
                                        └─ maxexp

   i.e. an overflow in two's complement. But leaving at least
   2 + max(0, maxexp2 + logn - e) itentical bits in the most
   significant part, such as

        0011111111111111111111111111110101000000
                                         └─ maxexp

   is sufficient. The second term of the max covers cases like:

                                       ┌─ maxexp2 + logn
        0000000000000000000000000000000000000111
                                         e ─┘

   (2^(maxexp2 + logn) being a bound on the error term, thus a bound
   on the value that will be added at the next iteration), which can
   be shifted to:

         ┌─ maxexp2 + logn
        0000000111000000000000000000000000000000
           e ─┘

   without triggering an overflow at the next iteration, but

        ┌─ maxexp2 + logn
        0000001110000000000000000000000000000000
          e ─┘

   is incorrect as a 1 could appear in the MSB (making the accumulator
   value negative) just with additions of positive numbers.

   Now, one needs to prove that this choice is possible, i.e. that

     cancel ≥ 2 + max(0, maxexp2 + logn - e)

   The condition err > q - 3 is equivalent to:

     minexp + logn > maxexp + cq - cancel - sq - 3

   Therefore

     cancel ≥ accumulator_bitsize - sq - 2 - logn
            ≥ logn + 1 + dq - 2 - logn = dq - 1

   so that if dq ≥ 3, the condition cancel ≥ 2 is satisfied. One also
   has:

     maxexp + cq - minexp = accumulator_bitsize ≥ logn + 2

   so that

     2 + maxexp2 + logn - e
       ≤ 2 + minexp + logn - (maxexp + cq - cancel)
       ≤ cancel

   proving the second part of the inequality.

   Note: It is expected that in general, the cancellation is not very
   large, so that the new additions in (3) will occur only in a small
   part of the accumulator, except in case of long carry propagation
   (see below).

7. Now, the accumulator contains a good approximation to the exact sum.
   Copy the rounded significand to the destination. One goal is to free
   the accumulator in case there is work to do in (8). Another reason is
   that if the correctly rounded result cannot be determined yet due to
   the table maker's dilemma (TMD), one cannot continue to accumulate
   since after some iterations, the required intermediate precision may
   become greater than the accumulator size.

8. If one cannot determine the correctly rounded sum and ternary value
   yet (due to the TMD), then reiterate at (3) using a specific window
   as if sq were 0, i.e. around maxexp + cq to maxexp - dq; basically,
   one determines the sign of an error term related to a breakpoint.
   There are 3 cases leading to additional reiterations:
            Rounding mode       Breakpoint
     A.       to nearest         midpoint
     B.       to nearest      machine number
     C.        directed       machine number
   A machine number is a number whose significand fits on sq bits, and
   a midpoint is a midpoint between two consecutive machine numbers.
   The correctly rounded sum (except in case B) and the ternary value
   will depend on the sign of the error term.
   Note: In particular if the rounding mode is to nearest, one needs
   to remember whether one is in case A or B.

9. Correct the significand if need be (+ or - 1 ulp), determine the
   exponent, and exit with the correct ternary value.

An example:

              [1]    [2]   A  [3]
  u0 = *****   |      |    .   |
  u1 =   ******|**    |    .   |
  u2 = ********|***** |    .   |
  u3 =         | *****|    .   |
  u4 =         |      |    ****|**
  u5 =         |      |     ***|*

At iteration 1, minexp is determined to be [1]; thus u0, a part of u1,
and a part of u2 are taken into account for the truncated sum. Then it
appears that an important cancellation occurred, and another step (3)
is needed. Since u1 was truncated, the new maxexp will be minexp, i.e.
[1]. At iteration 2, minexp is determined to be [2]; thus a part of u1,
a part of u2, and u3 are taken into account for the truncated sum. Now
assume that on this example, the error is small enough, but its sign is
unknown. Thus another step (3) is needed, with the conditions of (7).
Since no numbers were truncated at the previous iteration, maxexp is
the maximum exponent of the remaining numbers, here the one of u4, and
minexp is determined to be [3]. Assume that the sign of the error can
be determined now, so that we can return the rounded result with the
ternary value.

As a bonus, this will also solve overflow, underflow and normalization
issues, since everything is done in fixed point and the output exponent
will be considered only at the end (early overflow detection could also
be done).

A limb L = *zp in memory will generally contain a part of a significand.
One can define its exponent ze, such that the actual value of this limb
is L * 2^(ze-GMP_NUMB_BITS), i.e. ze is its exponent where the limb is
regarded as a number in [1/2,1[. If an array of limbs zp[] is regarded
as a significand in [1/2,1[, then the exponent of its actual value is
also ze.

Variables:
  tp: pointer to a temporary area that will contain a shifted value.
  wp: pointer to the accumulator.
  ts: the size of the temporary area, in limbs; then wp = tp + ts.
  ws: the size of the accumulator, in limbs.
  rn: number n' of inputs that are regular numbers (regular inputs).
  logn: ceil(log2(rn)).
  cq: logn + 1.
  sq: output precision (precision of the sum).
  dq: > logn, such that cq + sq + dq is a multiple of GMP_NUMB_BITS.
  maxexp: the maximum exponent of the bit-window of the inputs that is
          taken into account (for the current iteration), excluded.
  minexp: the minimum exponent of the bit-window of the inputs that is
          taken into account (for the current iteration), included.

Note 1: Data locality can be improved after the first iteration if the
shifted values are stored at the end of the temporary area instead of
the beginning. The reason is that only the least significant part of
the accumulator will be used once a good approximate value of the sum
is known, and the accumulator lies just after the temporary area. But
the gain would probably not be noticeable in practice.

Note 2: At step (4), it was considered to determine the number of
cancelled limbs instead of the number of cancelled bits in order to
avoid a non-trivial shift at step (6), making this step a bit faster.
However this choice would have required a larger value of dq (with
an increment of up to something like GMP_NUMB_BITS - 1) at the first
iteration to be able to handle a number of cancelled bits just below
GMP_NUMB_BITS (similar problem to the one of small leading digit in
high-radix floating-point representations).

Note 3: Compared with Ziv's strategy, the issue here is not really
exact values that are very close to a breakpoint, but cancellation.
Moreover, we do not need to recompute everything at each iteration.
The issue with the value very close to a breakpoint actually occurs
at step (8); however, contrary to the usual case, we do not want to
reiterate with more precision as this could take too much time and
memory. Indeed, due to a possible "hole" between the inputs, the
distance between the exact value and a breakpoint can be extremely
small.

*** To be considered in future versions ***
It seems that carry propagation (mpn_add_1 & mpn_sub_1 in the code) is
most often limited. But consider the following cases, where all inputs
have the minimal precision 2, and the output precision is p:
  u0 = 1
  u_i = (-1)^i * 2^(-p) for i > 0
Here long carry propagation will occur for each addition of the initial
iteration, so that the complexity will be O(n*p) instead of O(n+p) if
we choose to delay carry propagation (however such a choice may slower
the average case and take more memory, such as around 3*p instead of
2*p).
When a new iteration is needed due to cancellation, a second accumulator
was considered in some early version of the algorithm: the temporary
results of the computations during the new iteration would be stored in
this second accumulator, which would generally be small, thus limiting
carry propagation; this method is actually equivalent to delaying carry
propagation. It could help in some cases, such as:
  u0 = 2^q with some q > 0
  u1 = 1
  u2 = -2^q
  u_i = (-1)^i * 2^(-p) for i > 2
but such examples are very specific cases, and as seen with the first
example, a better way must be chosen if avoiding long carry propagation
is regarded as important (in all cases). Moreover, while the use of two
accumulators does not take much more memory (since both accumulators can
occupy the same area, with a flexible limit between them), it probably
makes the code a bit more complex, and noticeably slower if n is small.

$Id: sum 71941 2014-08-08 12:50:00Z vinc17/xvii $
